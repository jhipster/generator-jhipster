import { ParamMap } from '@angular/router';

export interface IFilterOptions {
  containsSameOption(option: IFilterOption): unknown;
  filterOptions: IFilterOption[];
  hasAnyFilterSet(): boolean;
  clear(): void;
  removeByName(name: string, value?: string): void;
  initializeFromParams(params: ParamMap): boolean;
  equals(other: IFilterOptions): boolean;
  clone(): IFilterOptions;
}

export interface IFilterOption {
  name: string;
  values: string[];
  isSet(): boolean;
  nameAsQueryParam(): string;
  removeValue(value: string): void;
  equals(other: IFilterOption): boolean;
}

export interface IFilterableComponent {
  clearFilter(filterName: string, value?: string): void;
  clearAllFilters(): void;
}

export class FilterOption implements IFilterOption {
  constructor(public name: string, public values: string[]) {}

  nameAsQueryParam(): string {
    return 'filter[' + this.name + ']';
  }

  isSet(): boolean {
    return this.values.length > 0;
  }

  removeValue(value: string): void {
    this.values = this.values.filter(thisValue => thisValue !== value);
  }

  equals(other: IFilterOption): boolean {
    return (
      this.values.every(thisValue => other.values.includes(thisValue)) && other.values.every(otherValue => this.values.includes(otherValue))
    );
  }
}

export class FilterOptions implements IFilterOptions {
  filterOptions: IFilterOption[] = [];

  hasAnyFilterSet(): boolean {
    return this.filterOptions.length > 0 && this.filterOptions.some(e => e.isSet());
  }

  clear(): void {
    this.filterOptions = [];
  }

  add(option: IFilterOption): void {
    this.filterOptions.push(option);
  }

  removeByName(name: string, value?: string): void {
    if (value === undefined) {
      this.filterOptions = this.filterOptions.filter(thisOption => thisOption.name !== name);
      return;
    }
    const option = this.filterOptions.find(thisOption => thisOption.name === name);
    option?.removeValue(value);
  }

  equals(other: IFilterOptions): boolean {
    return (
      this.filterOptions.every(thisOption => other.containsSameOption(thisOption)) &&
      other.filterOptions.every(otherOption => this.containsSameOption(otherOption))
    );
  }

  clone(): IFilterOptions {
    const newObject: FilterOptions = new FilterOptions();

    this.filterOptions.forEach(option => {
      newObject.add(new FilterOption(option.name, option.values));
    });

    return newObject;
  }

  initializeFromParams(params: ParamMap): boolean {
    const oldFilters: IFilterOptions = this.clone();

    this.clear();

    const filterRegex = /filter\[(.+)\]/;
    params.keys
      .filter(paramKey => filterRegex.test(paramKey))
      .forEach(matchingParam => {
        const matches = matchingParam.match(filterRegex);
        if (matches && matches.length > 1) {
          this.add(new FilterOption(matches[1], params.getAll(matchingParam)));
        }
      });

    return !oldFilters.equals(this);
  }

  containsSameOption(optionToSearch: IFilterOption): boolean {
    return this.filterOptions.some(option => option.name === optionToSearch.name && option.equals(optionToSearch));
  }
}
