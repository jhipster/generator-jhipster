import sinon from 'sinon';
import { expect } from 'esmocha';

import { SERVER_MAIN_RES_DIR } from '../generator-constants.mjs';
import { defaultHelpers as helpers } from '../../test/support/index.mjs';
import { GENERATOR_HEROKU } from '../generator-list.mjs';

const expectedFiles = {
  monolith: ['Procfile', `${SERVER_MAIN_RES_DIR}/config/bootstrap-heroku.yml`, `${SERVER_MAIN_RES_DIR}/config/application-heroku.yml`],
};

describe('generator - Heroku', () => {
  const herokuAppName = 'jhipster-test';
  let stub;

  beforeEach(() => {
    stub = sinon.stub();
    stub.withArgs('spawnCommand', 'heroku --version').yields(false);
    stub.withArgs('spawnCommand', 'heroku plugins').yields(false, 'heroku-cli-deploy');
    stub.withArgs('spawnCommand', 'git init').yields([false, '', '']);
  });
  afterEach(() => {
    stub.resetHistory();
  });

  describe('microservice application', () => {
    describe('with JAR deployment', () => {
      let runResult;
      beforeEach(async () => {
        stub.withArgs('spawnCommand', `heroku create ${herokuAppName}`).yields(false, '', '');
        stub.withArgs('spawnCommand', `heroku addons:create jawsdb:kitefin --as DATABASE --app ${herokuAppName}`).yields(false, '', '');
        stub
          .withArgs(
            'spawnCommand',
            `heroku config:set JHIPSTER_REGISTRY_URL=https://admin:changeme@sushi.herokuapp.com --app ${herokuAppName}`,
          )
          .yields(false, '', '')
          .returns({
            stdout: {
              // eslint-disable-next-line @typescript-eslint/no-empty-function
              on: () => {},
            },
          });
        runResult = await helpers
          .createJHipster(GENERATOR_HEROKU)
          .withJHipsterConfig({ applicationType: 'microservice' })
          .withOptions({ skipBuild: true })
          .withAnswers({
            herokuAppName,
            herokuRegion: 'us',
            herokuDeployType: 'jar',
            herokuJHipsterRegistryApp: 'sushi',
            herokuJHipsterRegistryUsername: 'admin',
            herokuJHipsterRegistryPassword: 'changeme',
            herokuJavaVersion: '17',
          })
          .withSpawnMock(stub)
          .run();
      });
      it('should match files snapshot', function () {
        expect(runResult.getSnapshot()).toMatchSnapshot();
      });
      it('creates expected files', () => {
        runResult.assertFileContent('.yo-rc.json', '"herokuDeployType": "jar"');
      });
    });
  });

  describe('monolith application', () => {
    describe('with an unavailable app name', () => {
      const autogeneratedAppName = 'jhipster-new-name';
      let runResult;
      beforeEach(async () => {
        stub
          .withArgs('spawnCommand', `heroku create ${herokuAppName}`)
          .yields(true, '', `Name ${herokuAppName} is already taken`)
          .returns({
            stdout: {
              // eslint-disable-next-line @typescript-eslint/no-empty-function
              on: () => {},
            },
          });
        stub.withArgs('spawnCommand', 'heroku create ').yields(false, `https://${autogeneratedAppName}.herokuapp.com`);
        stub
          .withArgs('spawnCommand', `heroku git:remote --app ${autogeneratedAppName}`)
          .yields(false, `https://${autogeneratedAppName}.herokuapp.com`);
        stub
          .withArgs('spawnCommand', `heroku addons:create jawsdb:kitefin --as DATABASE --app ${autogeneratedAppName}`)
          .yields(false, '', '');
        runResult = await helpers
          .createJHipster(GENERATOR_HEROKU)
          .withJHipsterConfig()
          .withOptions({ skipBuild: true })
          .withAnswers({
            herokuAppName,
            herokuRegion: 'us',
            herokuDeployType: 'jar',
            herokuForceName: 'No',
            herokuJavaVersion: '11',
          })
          .withSpawnMock(stub)
          .run();
      });
      it('should match files snapshot', function () {
        expect(runResult.getSnapshot()).toMatchSnapshot();
      });
      it('creates expected monolith files', () => {
        runResult.assertFile(expectedFiles.monolith);
        runResult.assertFileContent('.yo-rc.json', `"herokuAppName": "${autogeneratedAppName}"`);
      });
    });

    describe('with Git deployment', () => {
      let runResult;
      beforeEach(async () => {
        stub.withArgs('spawnCommand', `heroku create ${herokuAppName}`).yields(false, '', '');
        stub.withArgs('spawnCommand', `heroku addons:create jawsdb:kitefin --as DATABASE --app ${herokuAppName}`).yields(false, '', '');
        stub.withArgs('spawnCommand', 'git add .').yields(false, '', '');
        stub.withArgs('spawnCommand', 'git commit -m "Deploy to Heroku" --allow-empty').yields(false, '', '');
        stub
          .withArgs('spawnCommand', `heroku config:set MAVEN_CUSTOM_OPTS="-Pprod,heroku -DskipTests" --app ${herokuAppName}`)
          .yields(false, '', '');
        stub.withArgs('spawnCommand', `heroku buildpacks:add heroku/java --app ${herokuAppName}`).yields(false, '', '');
        stub.withArgs('spawnCommand', 'git push heroku HEAD:master').yields(false, '', '');
        runResult = await helpers
          .createJHipster(GENERATOR_HEROKU)
          .withJHipsterConfig()
          .withAnswers({
            herokuAppName,
            herokuRegion: 'us',
            herokuDeployType: 'git',
            herokuJavaVersion: '11',
          })
          .withSpawnMock(stub)
          .run();
      });
      it('should match files snapshot', function () {
        expect(runResult.getSnapshot()).toMatchSnapshot();
      });
      it('creates expected monolith files', () => {
        runResult.assertFile(expectedFiles.monolith);
        runResult.assertFileContent('.yo-rc.json', '"herokuDeployType": "git"');
      });
    });

    describe('in the US', () => {
      let runResult;
      beforeEach(async () => {
        stub.withArgs('spawnCommand', `heroku create ${herokuAppName}`).yields(false, '', '');
        stub.withArgs('spawnCommand', `heroku addons:create jawsdb:kitefin --as DATABASE --app ${herokuAppName}`).yields(false, '', '');
        runResult = await helpers
          .createJHipster(GENERATOR_HEROKU)
          .withJHipsterConfig()
          .withOptions({ skipBuild: true })
          .withAnswers({
            herokuAppName,
            herokuRegion: 'us',
            herokuDeployType: 'jar',
            herokuJavaVersion: '11',
          })
          .withSpawnMock(stub)
          .run();
      });
      it('should match files snapshot', function () {
        expect(runResult.getSnapshot()).toMatchSnapshot();
      });
      it('creates expected monolith files', () => {
        runResult.assertFile(expectedFiles.monolith);
        runResult.assertFileContent('.yo-rc.json', '"herokuDeployType": "jar"');
        runResult.assertFileContent(`${SERVER_MAIN_RES_DIR}/config/application-heroku.yml`, 'datasource:');
        runResult.assertNoFileContent(`${SERVER_MAIN_RES_DIR}/config/application-heroku.yml`, 'mongodb:');
      });
    });

    describe('in the EU', () => {
      let runResult;
      beforeEach(async () => {
        stub.withArgs('spawnCommand', `heroku create ${herokuAppName} --region eu`).yields(false, '', '');
        stub.withArgs('spawnCommand', `heroku addons:create jawsdb:kitefin --as DATABASE --app ${herokuAppName}`).yields(false, '', '');
        runResult = await helpers
          .createJHipster(GENERATOR_HEROKU)
          .withJHipsterConfig()
          .withOptions({ skipBuild: true })
          .withAnswers({
            herokuAppName,
            herokuRegion: 'eu',
            herokuDeployType: 'jar',
            herokuJavaVersion: '11',
          })
          .withSpawnMock(stub)
          .run();
      });
      it('should match files snapshot', function () {
        expect(runResult.getSnapshot()).toMatchSnapshot();
      });
      it('creates expected monolith files', () => {
        runResult.assertFile(expectedFiles.monolith);
      });
    });

    describe('with PostgreSQL', () => {
      let runResult;
      beforeEach(async () => {
        stub.withArgs('spawnCommand', `heroku create ${herokuAppName} --region eu`).yields(false, '', '');
        stub.withArgs('spawnCommand', `heroku addons:create heroku-postgresql --as DATABASE --app ${herokuAppName}`).yields(false, '', '');
        runResult = await helpers
          .createJHipster(GENERATOR_HEROKU)
          .withJHipsterConfig()
          .withOptions({ skipBuild: true })
          .withAnswers({
            herokuAppName,
            herokuRegion: 'eu',
            herokuDeployType: 'jar',
            herokuJavaVersion: '11',
          })
          .withSpawnMock(stub)
          .run();
      });
      it('should match files snapshot', function () {
        expect(runResult.getSnapshot()).toMatchSnapshot();
      });
      it('creates expected monolith files', () => {
        runResult.assertFile(expectedFiles.monolith);
        runResult.assertFileContent(`${SERVER_MAIN_RES_DIR}/config/application-heroku.yml`, 'datasource:');
        runResult.assertNoFileContent(`${SERVER_MAIN_RES_DIR}/config/application-heroku.yml`, 'mongodb:');
      });
    });

    describe('with existing app', () => {
      const existingHerokuAppName = 'jhipster-existing';
      let runResult;
      beforeEach(async () => {
        stub
          .withArgs('spawnCommand', `heroku apps:info --json ${existingHerokuAppName}`)
          .yields(false, `{"app":{"name":"${existingHerokuAppName}"}, "dynos":[]}`);
        stub
          .withArgs('spawnCommand', `heroku addons:create jawsdb:kitefin --as DATABASE --app ${existingHerokuAppName}`)
          .yields(false, '', '');
        runResult = await helpers
          .createJHipster(GENERATOR_HEROKU)
          .withJHipsterConfig({ herokuAppName: 'jhipster-existing', herokuDeployType: 'git' })
          .withOptions({ skipBuild: true })
          .withSpawnMock(stub)
          .run();
      });
      it('should match files snapshot', function () {
        expect(runResult.getSnapshot()).toMatchSnapshot();
      });
      it('creates expected monolith files', () => {
        runResult.assertFile(expectedFiles.monolith);
        runResult.assertFileContent('.yo-rc.json', `"herokuAppName": "${existingHerokuAppName}"`);
      });
    });

    describe('with elasticsearch', () => {
      let runResult;
      beforeEach(async () => {
        stub.withArgs('spawnCommand', `heroku create ${herokuAppName}`).yields(false, '', '');
        stub.withArgs('spawnCommand', `heroku addons:create jawsdb:kitefin --as DATABASE --app ${herokuAppName}`).yields(false, '', '');
        stub.withArgs('spawnCommand', `heroku addons:create bonsai --as BONSAI --app ${herokuAppName}`).yields(false, '', '');

        runResult = await helpers
          .createJHipster(GENERATOR_HEROKU)
          .withJHipsterConfig({ searchEngine: 'elasticsearch' })
          .withOptions({ skipBuild: true })
          .withAnswers({
            herokuAppName,
            herokuRegion: 'us',
            herokuDeployType: 'jar',
            herokuJavaVersion: '11',
          })
          .withSpawnMock(stub)
          .run();
      });
      it('should match files snapshot', function () {
        expect(runResult.getSnapshot()).toMatchSnapshot();
      });
      it('creates expected monolith files', () => {
        runResult.assertFile(expectedFiles.monolith);
        runResult.assertFileContent('.yo-rc.json', '"herokuDeployType": "jar"');
        runResult.assertFileContent(`${SERVER_MAIN_RES_DIR}/config/application-heroku.yml`, 'datasource:');
        runResult.assertNoFileContent(`${SERVER_MAIN_RES_DIR}/config/application-heroku.yml`, 'mongodb:');
      });
    });
  });
});
