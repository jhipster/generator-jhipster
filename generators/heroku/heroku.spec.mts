import sinon, { SinonStub } from 'sinon';
import { expect } from 'esmocha';

import { SERVER_MAIN_RES_DIR } from '../generator-constants.mjs';
import { defaultHelpers as helpers, runResult } from '../../test/support/index.mjs';
import { GENERATOR_HEROKU } from '../generator-list.mjs';

const expectedFiles = {
  monolith: ['Procfile', `${SERVER_MAIN_RES_DIR}/config/bootstrap-heroku.yml`, `${SERVER_MAIN_RES_DIR}/config/application-heroku.yml`],
};

const createSpawnCommandReturn = (resolvedValue?, data?) =>
  Object.assign(
    Promise.resolve({
      exitCode: 0,
      stdout: '',
      stderr: '',
      ...resolvedValue,
    }),
    {
      ...data,
      stdout: { on: () => {} },
      stderr: { on: () => {} },
    },
  );

describe('generator - Heroku', () => {
  const herokuAppName = 'jhipster-test';
  let stub: SinonStub;

  beforeEach(() => {
    stub = sinon.stub();
    // Add catch all
    stub.returns(createSpawnCommandReturn());

    stub.withArgs('spawnCommand', 'heroku --version').returns(createSpawnCommandReturn());
    stub.withArgs('spawnCommand', 'heroku plugins').returns(createSpawnCommandReturn({ stdout: 'heroku-cli-deploy', stderr: '' }));
    stub.withArgs('spawnCommand', 'git init').returns(createSpawnCommandReturn());
  });
  afterEach(() => {
    stub.resetHistory();
  });

  describe('microservice application', () => {
    describe('with JAR deployment', () => {
      beforeEach(async () => {
        stub.withArgs('spawnCommand', `heroku create ${herokuAppName}`).returns(createSpawnCommandReturn());
        stub
          .withArgs('spawnCommand', `heroku addons:create jawsdb:kitefin --as DATABASE --app ${herokuAppName}`)
          .returns(createSpawnCommandReturn());
        stub
          .withArgs(
            'spawnCommand',
            `heroku config:set JHIPSTER_REGISTRY_URL=https://admin:changeme@sushi.herokuapp.com --app ${herokuAppName}`,
          )
          .returns(createSpawnCommandReturn());
        await helpers
          .createJHipster(GENERATOR_HEROKU)
          .withJHipsterConfig({ applicationType: 'microservice' })
          .withOptions({ skipBuild: true })
          .withAnswers({
            herokuAppName,
            herokuRegion: 'us',
            herokuDeployType: 'jar',
            herokuJHipsterRegistryApp: 'sushi',
            herokuJHipsterRegistryUsername: 'admin',
            herokuJHipsterRegistryPassword: 'changeme',
            herokuJavaVersion: '17',
          })
          .withSpawnMock(stub)
          .run();
      });
      it('should match files snapshot', function () {
        expect(runResult.getSnapshot()).toMatchSnapshot();
      });
      it('creates expected files', () => {
        runResult.assertFileContent('.yo-rc.json', '"herokuDeployType": "jar"');
      });
    });
  });

  describe('monolith application', () => {
    describe('with an unavailable app name', () => {
      const autogeneratedAppName = '';
      beforeEach(async () => {
        stub
          .withArgs('spawnCommand', `heroku create ${herokuAppName}`)
          .returns(createSpawnCommandReturn({ exitCode: 1, stderr: `Name ${herokuAppName} is already taken` }));
        stub
          .withArgs('spawnCommand', `heroku git:remote --app ${autogeneratedAppName}`)
          .returns(createSpawnCommandReturn({ stdout: `https://${autogeneratedAppName}.herokuapp.com` }));
        stub
          .withArgs('spawnCommand', `heroku addons:create jawsdb:kitefin --as DATABASE --app ${autogeneratedAppName}`)
          .returns(createSpawnCommandReturn());
        await helpers
          .createJHipster(GENERATOR_HEROKU)
          .withJHipsterConfig()
          .withOptions({ skipBuild: true })
          .withAnswers({
            herokuAppName,
            herokuRegion: 'us',
            herokuDeployType: 'jar',
            herokuForceName: 'No',
            herokuJavaVersion: '11',
          })
          .withSpawnMock(stub)
          .run();
      });
      it('should match files snapshot', function () {
        expect(runResult.getSnapshot()).toMatchSnapshot();
      });
      it('creates expected monolith files', () => {
        runResult.assertFile(expectedFiles.monolith);
        runResult.assertFileContent('.yo-rc.json', `"herokuAppName": "${autogeneratedAppName}"`);
      });
      it('calls should match snapshot', () => {
        expect(runResult.getSpawnArgsUsingDefaultImplementation()).toMatchSnapshot();
      });
    });

    describe('with Git deployment', () => {
      beforeEach(async () => {
        stub.withArgs('spawnCommand', `heroku create ${herokuAppName}`).returns(createSpawnCommandReturn());
        stub
          .withArgs('spawnCommand', `heroku addons:create jawsdb:kitefin --as DATABASE --app ${herokuAppName}`)
          .returns(createSpawnCommandReturn());
        stub.withArgs('spawnCommand', 'git add .').returns(createSpawnCommandReturn());
        stub.withArgs('spawnCommand', 'git commit -m "Deploy to Heroku" --allow-empty').returns(createSpawnCommandReturn());
        stub
          .withArgs('spawnCommand', `heroku config:set MAVEN_CUSTOM_OPTS="-Pprod,heroku -DskipTests" --app ${herokuAppName}`)
          .returns(createSpawnCommandReturn());
        stub.withArgs('spawnCommand', `heroku buildpacks:add heroku/java --app ${herokuAppName}`).returns(createSpawnCommandReturn());
        stub.withArgs('spawnCommand', 'git push heroku HEAD:master').returns(createSpawnCommandReturn());
        await helpers
          .createJHipster(GENERATOR_HEROKU)
          .withJHipsterConfig()
          .withAnswers({
            herokuAppName,
            herokuRegion: 'us',
            herokuDeployType: 'git',
            herokuJavaVersion: '11',
          })
          .withSpawnMock(stub)
          .run();
      });
      it('should match files snapshot', function () {
        expect(runResult.getSnapshot()).toMatchSnapshot();
      });
      it('creates expected monolith files', () => {
        runResult.assertFile(expectedFiles.monolith);
        runResult.assertFileContent('.yo-rc.json', '"herokuDeployType": "git"');
      });
      it('calls should match snapshot', () => {
        expect(runResult.getSpawnArgsUsingDefaultImplementation()).toMatchSnapshot();
      });
    });

    describe('in the US', () => {
      beforeEach(async () => {
        stub.withArgs('spawnCommand', `heroku create ${herokuAppName}`).returns(createSpawnCommandReturn());
        stub
          .withArgs('spawnCommand', `heroku addons:create jawsdb:kitefin --as DATABASE --app ${herokuAppName}`)
          .returns(createSpawnCommandReturn());
        await helpers
          .createJHipster(GENERATOR_HEROKU)
          .withJHipsterConfig()
          .withOptions({ skipBuild: true })
          .withAnswers({
            herokuAppName,
            herokuRegion: 'us',
            herokuDeployType: 'jar',
            herokuJavaVersion: '11',
          })
          .withSpawnMock(stub)
          .run();
      });
      it('should match files snapshot', function () {
        expect(runResult.getSnapshot()).toMatchSnapshot();
      });
      it('creates expected monolith files', () => {
        runResult.assertFile(expectedFiles.monolith);
        runResult.assertFileContent('.yo-rc.json', '"herokuDeployType": "jar"');
        runResult.assertFileContent(`${SERVER_MAIN_RES_DIR}/config/application-heroku.yml`, 'datasource:');
        runResult.assertNoFileContent(`${SERVER_MAIN_RES_DIR}/config/application-heroku.yml`, 'mongodb:');
      });
      it('calls should match snapshot', () => {
        expect(runResult.getSpawnArgsUsingDefaultImplementation()).toMatchSnapshot();
      });
    });

    describe('in the EU', () => {
      beforeEach(async () => {
        stub.withArgs('spawnCommand', `heroku create ${herokuAppName} --region eu`).returns(createSpawnCommandReturn());
        stub
          .withArgs('spawnCommand', `heroku addons:create jawsdb:kitefin --as DATABASE --app ${herokuAppName}`)
          .returns(createSpawnCommandReturn());
        await helpers
          .createJHipster(GENERATOR_HEROKU)
          .withJHipsterConfig()
          .withOptions({ skipBuild: true })
          .withAnswers({
            herokuAppName,
            herokuRegion: 'eu',
            herokuDeployType: 'jar',
            herokuJavaVersion: '11',
          })
          .withSpawnMock(stub)
          .run();
      });
      it('should match files snapshot', function () {
        expect(runResult.getSnapshot()).toMatchSnapshot();
      });
      it('creates expected monolith files', () => {
        runResult.assertFile(expectedFiles.monolith);
      });
      it('calls should match snapshot', () => {
        expect(runResult.getSpawnArgsUsingDefaultImplementation()).toMatchSnapshot();
      });
    });

    describe('with PostgreSQL', () => {
      beforeEach(async () => {
        stub.withArgs('spawnCommand', `heroku create ${herokuAppName} --region eu`).returns(createSpawnCommandReturn());
        stub
          .withArgs('spawnCommand', `heroku addons:create heroku-postgresql --as DATABASE --app ${herokuAppName}`)
          .returns(createSpawnCommandReturn());
        await helpers
          .createJHipster(GENERATOR_HEROKU)
          .withJHipsterConfig()
          .withOptions({ skipBuild: true })
          .withAnswers({
            herokuAppName,
            herokuRegion: 'eu',
            herokuDeployType: 'jar',
            herokuJavaVersion: '11',
          })
          .withSpawnMock(stub)
          .run();
      });
      it('should match files snapshot', function () {
        expect(runResult.getSnapshot()).toMatchSnapshot();
      });
      it('creates expected monolith files', () => {
        runResult.assertFile(expectedFiles.monolith);
        runResult.assertFileContent(`${SERVER_MAIN_RES_DIR}/config/application-heroku.yml`, 'datasource:');
        runResult.assertNoFileContent(`${SERVER_MAIN_RES_DIR}/config/application-heroku.yml`, 'mongodb:');
      });
      it('calls should match snapshot', () => {
        expect(runResult.getSpawnArgsUsingDefaultImplementation()).toMatchSnapshot();
      });
    });

    describe('with existing app', () => {
      const existingHerokuAppName = 'jhipster-existing';
      beforeEach(async () => {
        stub
          .withArgs('spawnCommand', `heroku apps:info --json ${existingHerokuAppName}`)
          .returns(createSpawnCommandReturn({ stdout: `{"app":{"name":"${existingHerokuAppName}"}, "dynos":[]}` }));
        stub
          .withArgs('spawnCommand', `heroku addons:create jawsdb:kitefin --as DATABASE --app ${existingHerokuAppName}`)
          .returns(createSpawnCommandReturn());
        await helpers
          .createJHipster(GENERATOR_HEROKU)
          .withJHipsterConfig({ herokuAppName: 'jhipster-existing', herokuDeployType: 'git' })
          .withOptions({ skipBuild: true })
          .withSpawnMock(stub)
          .run();
      });
      it('should match files snapshot', function () {
        expect(runResult.getSnapshot()).toMatchSnapshot();
      });
      it('creates expected monolith files', () => {
        runResult.assertFile(expectedFiles.monolith);
        runResult.assertFileContent('.yo-rc.json', `"herokuAppName": "${existingHerokuAppName}"`);
      });
      it('calls should match snapshot', () => {
        expect(runResult.getSpawnArgsUsingDefaultImplementation()).toMatchSnapshot();
      });
    });

    describe('with elasticsearch', () => {
      beforeEach(async () => {
        stub.withArgs('spawnCommand', `heroku create ${herokuAppName}`).returns(createSpawnCommandReturn());
        stub
          .withArgs('spawnCommand', `heroku addons:create jawsdb:kitefin --as DATABASE --app ${herokuAppName}`)
          .returns(createSpawnCommandReturn());
        stub.withArgs('spawnCommand', `heroku addons:create bonsai --as BONSAI --app ${herokuAppName}`).returns(createSpawnCommandReturn());

        await helpers
          .createJHipster(GENERATOR_HEROKU)
          .withJHipsterConfig({ searchEngine: 'elasticsearch' })
          .withOptions({ skipBuild: true })
          .withAnswers({
            herokuAppName,
            herokuRegion: 'us',
            herokuDeployType: 'jar',
            herokuJavaVersion: '11',
          })
          .withSpawnMock(stub)
          .run();
      });
      it('should match files snapshot', function () {
        expect(runResult.getSnapshot()).toMatchSnapshot();
      });
      it('creates expected monolith files', () => {
        runResult.assertFile(expectedFiles.monolith);
        runResult.assertFileContent('.yo-rc.json', '"herokuDeployType": "jar"');
        runResult.assertFileContent(`${SERVER_MAIN_RES_DIR}/config/application-heroku.yml`, 'datasource:');
        runResult.assertNoFileContent(`${SERVER_MAIN_RES_DIR}/config/application-heroku.yml`, 'mongodb:');
      });
      it('calls should match snapshot', () => {
        expect(runResult.getSpawnArgsUsingDefaultImplementation()).toMatchSnapshot();
      });
    });
  });
});
