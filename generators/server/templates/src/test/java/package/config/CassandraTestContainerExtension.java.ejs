package <%= packageName %>.config;

import static java.nio.file.Files.newDirectoryStream;
import static java.nio.file.Paths.get;
import static java.util.Spliterator.SORTED;
import static java.util.Spliterators.spliteratorUnknownSize;
import static java.util.stream.StreamSupport.stream;

import com.datastax.driver.core.Cluster;
import com.datastax.driver.core.Session;
import com.datastax.oss.driver.api.core.CqlSession;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.URISyntaxException;
import java.net.URL;
import java.nio.file.Path;
import java.time.Duration;
import java.util.Iterator;
import java.util.Spliterator;

import com.datastax.oss.driver.api.core.CqlSessionBuilder;
import com.datastax.oss.driver.api.core.config.DefaultDriverOption;
import com.datastax.oss.driver.api.core.config.DriverConfigLoader;
import org.cassandraunit.CQLDataLoader;
import org.cassandraunit.dataset.cql.ClassPathCQLDataSet;
import org.junit.jupiter.api.extension.BeforeAllCallback;
import org.junit.jupiter.api.extension.ExtensionContext;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.testcontainers.containers.CassandraContainer;

/**
 * Base class for starting/stopping Cassandra during tests.
 */
public class CassandraTestContainerExtension implements BeforeAllCallback {


    private static final ThreadLocal<CassandraContainer> THREAD_CONTAINER = new ThreadLocal<>();
    private static final Logger log = LoggerFactory.getLogger(CassandraTestContainerExtension.class);
    private static final Integer DATABASE_REQUEST_TIMEOUT = 20;


    @Override
    public void beforeAll(ExtensionContext context) {
        if (null == THREAD_CONTAINER.get()) {
            CassandraContainer container = new CassandraContainer("<%= DOCKER_CASSANDRA %>");

            container.start();
            Cluster cluster = container.getCluster();

            try(Session session = cluster.connect()) {
                createTestKeyspace(session);
            }
            CqlSession cqlSession = new CqlSessionBuilder()
                .addContactPoint(
                    new InetSocketAddress(
                        container.getHost(),
                        container.getMappedPort(CassandraContainer.CQL_PORT))
                    )
                .withLocalDatacenter(cluster.getMetadata().getAllHosts().iterator().next().getDatacenter())
                .withKeyspace(CQLDataLoader.DEFAULT_KEYSPACE_NAME)
                .withConfigLoader(getConfigLoader())
                .build();
            CQLDataLoader dataLoader = new CQLDataLoader(cqlSession);
            applyScripts(dataLoader, "config/cql/changelog/", "*.cql");
            cqlSession.close();

            THREAD_CONTAINER.set(container);

        }
    }

    private DriverConfigLoader getConfigLoader() {
        return  DriverConfigLoader.programmaticBuilder()
            .withDuration(DefaultDriverOption.REQUEST_TIMEOUT, Duration.ofSeconds(DATABASE_REQUEST_TIMEOUT))
            .build();
    }

    public static ThreadLocal<?> getThreadContainer() {
        return THREAD_CONTAINER;
    }



    private void createTestKeyspace(Session session) {
        String createQuery =
            "CREATE KEYSPACE " + CQLDataLoader.DEFAULT_KEYSPACE_NAME + " WITH replication={'class' : 'SimpleStrategy', 'replication_factor':1}";
        session.execute(createQuery);
    }

    private void applyScripts(CQLDataLoader dataLoader, String cqlDir, String pattern) {
        URL dirUrl = ClassLoader.getSystemResource(cqlDir);
        if (dirUrl == null) { // protect for empty directory
            return;
        }

        Iterator<Path> pathIterator = null;
        try {
            pathIterator = newDirectoryStream(get(dirUrl.toURI()), pattern).iterator();
        } catch (IOException e) {
            log.error("error trying to reading CQL chagelog", e);
        } catch (URISyntaxException e) {
            log.error("error trying to get CQL chagelog uri", e);
        }

        Spliterator<Path> pathSpliterator = spliteratorUnknownSize(pathIterator, SORTED);
        stream(pathSpliterator, false)
            .map(Path::getFileName)
            .map(Path::toString)
            .sorted()
            .map(file -> cqlDir + file)
            .map(dataSetLocation -> new ClassPathCQLDataSet(dataSetLocation, false, false, dataLoader.getSession().getKeyspace().get().toString()))
            .forEach(dataLoader::load);
    }

}
